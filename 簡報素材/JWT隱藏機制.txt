1.1 登入 API 修改（將 JWT 存入 HttpOnly Cookie）
java
複製
編輯
@PostMapping("/user/login")
public ResponseEntity<ApiResponse<Map<String, Object>>> login(@RequestBody Map<String, String> data, HttpSession session, HttpServletResponse response) {
    String sesstionAuthCode = session.getAttribute("authcode") + "";  // 获取验证码

    try {
        UserCert userCert = userLoginService.login(data.get("email"), data.get("password"), data.get("authcode"), sesstionAuthCode);

        // 生成 JWT token
        String token = JwtUtil.generateToken(userCert.getUserId().toString());
        System.out.println("userID:" + userCert.getUserId().toString() + "[已經轉換成] " + token);

        // 把 userCert 放進 session，保持原本session邏輯不動
        session.setAttribute("userCert", userCert);

        // 設置 JWT Token 在 HttpOnly Cookie 中（增加安全性）
        Cookie cookie = new Cookie("jwtToken", token);  // 使用 httpOnly cookie 儲存 token
        cookie.setHttpOnly(true); // 防止 JavaScript 訪問，避免 XSS 攻擊
        cookie.setMaxAge(3600);   // 設定 cookie 有效期為 1 小時
        cookie.setPath("/");      // 適用於整個應用
        response.addCookie(cookie);  // 設置 Cookie

        // 回應資料
        Map<String, Object> responseData = new HashMap<>();
        responseData.put("userCert", userCert);
        responseData.put("message", "登入成功");

        return ResponseEntity.ok(ApiResponse.success(200, "登入成功", responseData));
    } catch (RuntimeException e) {
        if (session.getAttribute("userCert") != null) {
            session.removeAttribute("userCert");  // 如果登入失敗，清除 session
        }
        return ResponseEntity.ok(ApiResponse.error(400, "登入失敗:" + e.getMessage()));
    }
}
重點：
在登入成功後，將 JWT token 儲存到 HttpOnly Cookie 中，避免它在前端暴露。

HttpOnly 會確保 cookie 只能由瀏覽器發送給伺服器，JavaScript 無法直接訪問它，增加安全性。

📚 2. 取 Token（從 Cookie 中提取 JWT）
2.1 如何在後端從 Cookie 中取出 JWT
當用戶每次發送請求時，會帶上 HttpOnly Cookie，可以從 HttpServletRequest 中提取出來。

例：用戶資料 API，從 Cookie 中提取 JWT
java
複製
編輯
@GetMapping("/user/profile")
public ResponseEntity<ApiResponse<UserCert>> getUserProfile(HttpServletRequest request, HttpSession session) {
    // 從 request 中取得 Cookie
    Cookie[] cookies = request.getCookies();
    String jwtToken = null;

    if (cookies != null) {
        for (Cookie cookie : cookies) {
            if (cookie.getName().equals("jwtToken")) { // 查找名為 jwtToken 的 Cookie
                jwtToken = cookie.getValue(); // 取得其值
                break;
            }
        }
    }

    if (jwtToken == null) {
        return ResponseEntity.ok(ApiResponse.error(400, "未找到有效的 token"));
    }

    try {
        // 解析 JWT token，並獲得 userId
        String userId = JwtUtil.parseToken(jwtToken);  // 假設你的 JwtUtil 有一個解析 JWT 的方法

        // 這裡可選，若你需要根據 JWT 中的 userId 查找用戶資料，可以查詢資料庫
        UserCert userCert = userService.getUserById(userId);
        
        // 回應 user 資訊
        return ResponseEntity.ok(ApiResponse.success(200, "獲取用戶資料成功", userCert));
    } catch (Exception e) {
        return ResponseEntity.ok(ApiResponse.error(400, "無效的 token"));
    }
}
重點：
在這裡，我們通過 HttpServletRequest 來取出所有 cookies，並尋找名為 jwtToken 的 cookie。

一旦取出 token，可以解析它並使用其中的資料（如 userId）來執行後續操作。

📚 3. 登出 API（清除 Session 和 Cookie）
登出時，我們要清除 session 和 cookie。

3.1 登出 API 修改（清除 Session 和 Cookie）
java
複製
編輯
@GetMapping("/user/logout")
public ResponseEntity<ApiResponse<String>> logout(HttpServletRequest request, HttpServletResponse response, HttpSession session) {
    // 清除 session 中的用戶資料
    session.invalidate();  // 無論如何，先清除 session

    // 清除 HttpOnly Cookie 中的 JWT token
    Cookie cookie = new Cookie("jwtToken", null); // 將 cookie 設為 null，實際上會使它無效
    cookie.setHttpOnly(true);
    cookie.setMaxAge(0);  // 設定 cookie 立即過期
    cookie.setPath("/");  // 要清除整個網站範圍的 cookie
    response.addCookie(cookie);  // 更新瀏覽器

    return ResponseEntity.ok(ApiResponse.success(200, "登出成功"));
}